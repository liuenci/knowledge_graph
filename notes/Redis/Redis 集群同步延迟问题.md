对于需要保证高可用的 Redis 而言，需要避免出现单点故障问题，基本上都会采取多机器集群部署。
​

但是 Redis 主备延迟是肯定会存在的，因此会出现一系列问题。
​

#### 例子
在集群场景下，如果 A 在 master 拿到了锁，在没有把数据同步到 slave 时，master 挂掉了。B 再拿锁就会从 slave 拿锁，并且会拿到锁。此时就会出现两个线程同时拿到锁。
​

两个线程都能获取锁的时候，说明两个线程不是互斥的，这里主要的原因是因为从节点的 Redis 在主节点奔溃之后，立马升级成了主 Redis 节点，如果能够过了 Redis key 的 TTL 再升级（延迟升级），或者升级成主 Redis 但是客户端等过了 Redis key 的 TTL 之后再去获取锁，就能产生互斥效果，但是实际上往往不是想象中的那么美好。
​

#### RedLock
基于上面的场景，Redis 的作者提出了一个叫做 RedLock 的算法。
​

RedLock 全名 Redis Distributed Lock，也就是通过 Redis 实现的分布式锁。
​

假设 Redis 的部署模式是 Redis Cluster，总共有 5 个 Master 节点。

1. 获取当前时间戳。
1. 客户端尝试按照顺序使用相同的 key value 获取获取所有 Redis 节点的锁，在这里获取锁的时间一定是比锁过期的时间短很多的，这里是为了不要过长时间等待已经关闭的 Redis 服务。例如：TTL 为 5s，设置尝试获取锁的时间最多为 1s，如果 1s 内无法获取锁，就会立马尝试获取下个锁。
1. 客户端通过获取所有能获取的锁后的时间减去第一步的时间，这个时间差要小于 TTL 时间并且至少有 3 个 Redis 实例成功拿到锁，才算真正的获取锁成功。
1. 如果成功获取锁，则锁的真正有效时间是 TTL 减去第三步的时间差的时间。例如：TTL 为 5s，获取所有的锁用了 2s，则真正锁有效时间为 3s，再减去一个时钟漂移的时间，最后的时间应该是小于 3s 的。
1. 如果客户端获取锁失败，就会去删除所有 Redis 实例，因为可能已经获取了小于 3 个锁，必须释放叼，否则会影响到其他客户端获取锁。

​

#### 备注

- TTL：Time To Live，指的是 Redis key 的过期时间或者有效生存时间。
- clock drift：时钟漂移，指的是两个服务器之间时间流速基本相同的情况下，两个服务器时间的差值，如果服务器之间距离过远会造成时钟流速漂移值过大。



#### 总结

- TTL 时长要大于正常业务执行的时间 + 获取所有 Redis 服务消耗时间 + 时钟漂移的时间。
- 获取 Redis 所有服务器消耗的时间要远远小于 TTL 的时间，并且获取成功的锁个数要在总数的一半以上：N/2 + 1。
- 尝试获取所有锁失败后，重新尝试一定要有一定次数限制。
