#### 表级锁
开销小，加锁快，不会出现死锁，同时锁定的颗粒度大，发生锁冲突的概率最高，并发度最低。

#### 行级锁
开销大，加锁慢，会出现死锁，同时锁定的颗粒度最小，发生锁冲突的概率最低，并发度也最高。

由于 MySQL 行锁是通过给索引加锁，因此在不通过索引条件查询的时候，InnoDB 确实使用的是表锁，而不是行锁。

##### 行级锁与死锁
MyISAM 中是不会产生死锁的，因为 MyISAM 总是一次性获得所需的全部锁，要么全部满足，要么全部等待。而在 InnoDB 中，锁是逐步获取的，就有可能造成死锁。

在 MySQL 中，行级锁并不是直接锁记录，而是直接锁索引。索引分为主键索引和非主键索引两种，如果一条 SQL 语句操作了主键索引，MySQL 就会锁定这条主键索引。如果此时另外一条 SQL 语句锁定了该表的非主键索引，MySQL 就会先锁定该非主键索引，再锁定相关的主键索引。在进行 update delete 时，MySQL 不仅锁定 where 条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的 next-key locking。

当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引；另外一个锁定了非主键索引，再等待主键索引，就有可能产生死锁。

发生死锁后，InnoDB 一般都能检测到，并使一个事务释放锁回退，另一个获取锁完成事务。

#### 页面锁
开销和加锁时间介于标所和行锁之间，会出现死锁，锁力度介于表锁和行锁之间，并发度一般。
